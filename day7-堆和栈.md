#### 堆和栈

Java把内存分成两种，一种叫做栈内存，一种叫做堆内存

在函数中定义的**一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配**。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

**堆内存用于存放由new创建的对象和数组**。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。

引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，**数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，**实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!





#### 数组的基本特点

1. 其长度是确定的，即数组在被创建后，它的大小不可改变。
2. 数组中的元素必须是相同类型，不允许出现混合类型。
3. 数组中的元素可以是任何数据类型，包括基本类型和引用类型。
4. 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。Java中对象是存放在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的。







#### 二维数组内存分配

区分三种初始化方式：

**格式一：**

　　　　数据类型[][] 数组名 = new 数据类型`[m][n]`;

　　　　　　　　　　m:表示这个二维数组有多少个一维数组。
　　　　　　　　　　n:表示每一个一维数组的元素有多少个。

　　　　//例：`int arr[][]=new int [3][2]`;

　　　　如下图

 ![img](https://img2018.cnblogs.com/blog/1665017/201904/1665017-20190422170639701-1517623404.png)

**格式二：**

　　　　数据类型[][] 数组名 = new 数据类型`[m][]`;
　　　　　　m:表示这个二维数组有多少个一维数组。
　　　　　　列数没有给出，可以动态的给。这一次是一个变化的列数。

如下图

![img](https://img2018.cnblogs.com/blog/1665017/201904/1665017-20190422170937110-2007521001.png)

**格式三：**
　　　　基本格式：
　　　　　　数据类型[][] 数组名 = new 数据类型[][]{{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}};
　　　　简化版格式：
　　　　　　数据类型[][] 数组名 = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}};

如下图：

![img](https://img2018.cnblogs.com/blog/1665017/201904/1665017-20190422171039271-2080340853.png)

小结：引用类型的默认值为null，定义二维数组时，会在堆内存为其分配内存空间（必须知道二维数组的行数，即一维数组的个数，才能够为其分配内存空间），首先给一个地址值0x001给arr，然后为二维数组里的一维数组分配内存空间，分别给一个地址值给一维数组，即0x0001给arr[0]，0x0002给arr[1]，0x0003给arr[2]。如果arr[3][]第二个元素值没有给出（相当于里面的一维数组的元素个数不知道），即以格式2定义二维数组，那么就无法为一维数组静态的分配内存空间了，即打印出来的arr[0],arr[1],arr[2]地址值是默认值null，可以动态的为其分配内存空间。