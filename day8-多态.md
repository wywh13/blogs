## 面向对象

#### **1.多态是方法的多态**

1. 静态方法在类加载时已加载，调用时调用定义类型的方法，非静态方法在重写后调用实际对象的方法。

   ```
   B b = new A();//B为父类，A为子类,父类引用指向子类对象
   b.test();//若test()为静态方法，则调用父类的静态方法；若test()为子          //类中已经重写的方法，则调用new出来的子类对象的。
   ```

2. 当用父类引用指向子类对象时，该对象继承的是父类的访问权限，即无法访问子类中父类没有的变量及方法；但访问重写过的方法时访问的是子类的方法。例：

   ![ä»JVMè§åº¦çJavaå¤æ](http://p3.pstatp.com/large/1f8c000507d84f7ec409)

   ![ä»JVMè§åº¦çJavaå¤æ](http://p3.pstatp.com/large/1f8c000508087a4f1f5d)

输出结果为：

![从JVM角度看Java多态](http://p3.pstatp.com/large/212e0001335c015dff2c)

结论：Father  c  =  new  Child()   在c的眼里只能看到 child 里面的 father 属性！可以发现c.eat()调用的实际上是子类的eat（是因为子类重写覆盖了父类方法）， 但c.age调用的还是父类的age（*属性/变量不存在重写和覆盖*），而c.play()则不会通过编译。

##### **原理**

![img](https://images2015.cnblogs.com/blog/1034798/201705/1034798-20170520005945478-1378550249.png)

在java的引用中Father不但指定了c以何种方式访问内存，也规定了能够访问内存空间的大小。Father实例对象的大小是占两行，但Child实例对象占三行（简单量化一下）。所以虽然c指向的是Child实例对象，但是前面有Father修饰它，它也只能访问两行的数据，也就是说c根本访问不到Child类中的age！！！只能访问到Father类的age，所以输出40（只有方法存在重写/覆盖，属性/变量不存在重写/覆盖）。

![ä»JVMè§åº¦çJavaå¤æ](http://p1.pstatp.com/large/1f8c0005085297d6199c)

Parent的方法表占三行，Child的方法表占4行，c虽然指向了Child类的实例对象，而对象中也有指针指向Child类的方法表，但是由于c受到了Father的修饰，通过c也只能访问到Child方法表中前3行的内容。在方法表的形成过程中，子类重写的方法会**覆盖掉**表中原来的数据，也就是Child类的方法表的第三行是指向Child.eat的引用，而不是指向Parent.eat（因为方法表产生了覆盖），所以c访问到的是Child.eat。也就是子类的方法！这种情况下，c是没有办法直接访问到父类的eat方法的。可将父类引用指向的子类对象通过强制转换改变该对象的访问方式，达到访问子类本类属性或方法的目的。

#### 2.抽象类及接口

##### 1.抽象类

包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：

- 抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），默认情况下默认为 public。
- 抽象类不能用来创建对象；
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。
- 在其他方面，抽象类和普通的类并没有区别。

##### 2.接口

接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final变量，用 private 修饰会报编译错误），而方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加"抽象"，并且一般情况下不在接口中定义变量。允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。

##### 3.抽象类与接口的对比

###### 1、语法层面上的区别

- 1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
- 2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
- 3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
- 4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

###### 2、设计层面上的区别

1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 **飞行** 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和 ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

![img](https://images2015.cnblogs.com/blog/1064302/201612/1064302-20161230090438195-1243745647.png)

##### 3.什么时候使用抽象类和接口

- 如果拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。
- 如果想实现多重继承，那么必须使用接口。由于**Java不支持多继承**，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
- 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

#### **3.内部类**

静态内部类和静态属性，静态代码块一样，在第一次被使用（并非实例化）的时候加载，在此之前不加载。